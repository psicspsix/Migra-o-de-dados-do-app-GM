<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <!-- ... (estilos mantidos iguais) ... -->
</head>
<body>
    <!-- ... (HTML mantido igual) ... -->

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getDatabase, ref, onValue, push, update, remove, set } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js";

        const firebaseConfig = { /* ... (configuração mantida igual) ... */ };
        const app = initializeApp(firebaseConfig);
        const db = getDatabase(app);
        const tasksRef = ref(db, 'tasks');
        let editingTaskKey = null;
        let editingSubtask = null;
        let addingSubtaskToKey = null;
        let currentCategory = 'mainProjects';
        let expandedTasks = {};
        let targetTaskKey = null;

        console.log("Firebase conectado com sucesso!");

        // Funções auxiliares (scrollToTarget, saveTask, resetForm, editTask, addSubtask, editSubtask) mantidas iguais

        function toggleTask(key) {
            console.log("toggleTask chamado com key:", key);
            const taskRef = ref(db, `tasks/${key}`);
            onValue(taskRef, (snapshot) => {
                const task = snapshot.val();
                update(taskRef, { completed: !task.completed })
                    .then(() => console.log(`Tarefa ${key} atualizada no Firebase: completed=${!task.completed}`))
                    .catch(error => console.error("Erro ao atualizar tarefa:", error));
            }, { onlyOnce: true });
        }

        function toggleSubtask(parentKey, path, subtaskIndex) {
            console.log("toggleSubtask chamado com:", { parentKey, path, subtaskIndex });
            const taskRef = ref(db, `tasks/${parentKey}`);
            onValue(taskRef, (snapshot) => {
                const task = snapshot.val();
                let current = task;
                const parts = path.split('/').filter(p => p !== '');
                for (let i = 0; i < parts.length; i++) {
                    const index = parseInt(parts[i]);
                    current = current.subtasks[index];
                }
                current.subtasks[subtaskIndex].completed = !current.subtasks[subtaskIndex].completed;
                update(taskRef, task)
                    .then(() => console.log(`Subtarefa ${parentKey}/${path}/${subtaskIndex} atualizada no Firebase`))
                    .catch(error => console.error("Erro ao atualizar subtarefa:", error));
            }, { onlyOnce: true });
        }

        // Funções auxiliares (deleteTask, deleteSubtask, toggleNotes, updateNotes, updateSubtaskNotes, toggleCategoryDropdown, toggleSubtasks, changeCategory, formatDate, isPastDue, isToday, isOneDayPast, isTwoOrMoreDaysPast, setCategory, getEarliestDueDate, shouldExpandTask, getNestedSubtasks, getParentTask) mantidas iguais

        function renderSubtasks(key, task, container, path = '', level = 1) {
            if (!task.subtasks || task.subtasks.length === 0 || level > 4) return;
            const sortedSubtasks = [...task.subtasks].sort((a, b) => {
                if (a.completed !== b.completed) return a.completed - b.completed;
                const dateA = a.dueDate || '9999-12-31';
                const dateB = b.dueDate || '9999-12-31';
                if (dateA !== dateB) return dateA.localeCompare(dateB);
                return b.priority - a.priority;
            });

            sortedSubtasks.forEach((subtask, index) => {
                const subLi = document.createElement('li');
                subLi.className = `subtask-level-${level} ${subtask.completed ? 'completed' : ''}`;
                const subPath = path ? `${path}/${index}` : `${index}`;
                const fullPath = `${key}/${subPath}`;
                const isSubtaskBoldItalic = isPastDue(subtask.dueDate, subtask.completed);
                const hasSubtasks = subtask.subtasks && subtask.subtasks.length > 0;

                subLi.innerHTML = `
                    <div class="task-row">
                        ${hasSubtasks ? `<button class="expand-btn">${expandedTasks[fullPath] ? '−' : '+'}</button>` : '<span class="expand-placeholder"></span>'}
                        <input type="checkbox" ${subtask.completed ? 'checked' : ''} data-id="${fullPath}">
                        <span class="task-text ${isSubtaskBoldItalic ? 'bold-italic' : ''}">${subtask.text} | Data: ${formatDate(subtask.dueDate)} | Prioridade: ${subtask.priority}</span>
                        <button class="edit-btn">Editar</button>
                        <button class="delete-btn">Excluir</button>
                        ${level < 4 ? '<button class="subtask-btn">Subtarefa</button>' : ''}
                        ${subtask.notes && subtask.notes.trim() !== '' ? '<span class="has-notes">(Contém Nota)</span>' : ''}
                    </div>
                    <div class="notes">
                        <textarea rows="3">${subtask.notes || ''}</textarea>
                    </div>
                    <div class="subtasks-container ${expandedTasks[fullPath] ? 'visible' : ''}"></div>
                `;

                const subtasksContainer = subLi.querySelector('.subtasks-container');
                if (hasSubtasks) {
                    renderSubtasks(key, subtask, subtasksContainer, subPath, level + 1);
                }
                container.appendChild(subLi);

                subLi.querySelector('.task-text').addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleNotes(subLi);
                });
                if (hasSubtasks) {
                    subLi.querySelector('.expand-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleSubtasks(key, subPath, subLi);
                    });
                }
                subLi.querySelector('.edit-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    editSubtask(key, path, index);
                });
                subLi.querySelector('.delete-btn').addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteSubtask(key, path, index);
                });
                if (level < 4) {
                    const subtaskBtn = subLi.querySelector('.subtask-btn');
                    if (subtaskBtn) {
                        subtaskBtn.addEventListener('click', (e) => {
                            e.stopPropagation();
                            addSubtask(key, subPath);
                        });
                    }
                }
                const notesIndicator = subLi.querySelector('.has-notes');
                if (notesIndicator) {
                    notesIndicator.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleNotes(subLi);
                    });
                }
                subLi.querySelector('textarea').addEventListener('change', (e) => updateSubtaskNotes(key, path, index, e.target));
                subLi.querySelector('textarea').addEventListener('click', (e) => e.stopPropagation());
            });
        }

        function renderTasks() {
            onValue(tasksRef, (snapshot) => {
                const tasks = snapshot.val();
                const taskList = document.getElementById('taskList');
                taskList.innerHTML = tasks ? '' : '<li>Sem tarefas ainda.</li>';
                const taskArray = Object.entries(tasks || {})
                    .filter(([_, task]) => currentCategory === 'all' || task.category === currentCategory)
                    .sort((a, b) => {
                        if (a[1].completed !== b[1].completed) return a[1].completed - b[1].completed;
                        const earliestDateA = getEarliestDueDate(a[1]);
                        const earliestDateB = getEarliestDueDate(b[1]);
                        if (earliestDateA !== earliestDateB) return earliestDateA.localeCompare(earliestDateB);
                        return b[1].priority - a[1].priority;
                    });

                taskArray.forEach(([key, task]) => {
                    const li = document.createElement('li');
                    li.setAttribute('data-key', key);
                    li.className = task.completed ? 'completed' : '';
                    const isTaskBoldItalic = isPastDue(task.dueDate, task.completed);
                    const hasSubtasks = task.subtasks && task.subtasks.length > 0;
                    if (shouldExpandTask(task)) expandedTasks[key] = true;

                    li.innerHTML = `
                        <div class="task-row">
                            ${hasSubtasks ? `<button class="expand-btn">${expandedTasks[key] ? '−' : '+'}</button>` : '<span class="expand-placeholder"></span>'}
                            <input type="checkbox" ${task.completed ? 'checked' : ''} data-id="${key}">
                            <span class="task-text ${isTaskBoldItalic ? 'bold-italic' : ''}">${task.text} | Data: ${formatDate(task.dueDate)} | Prioridade: ${task.priority}</span>
                            <div class="category-dropdown">
                                <button class="category-btn">Categoria</button>
                                <div class="dropdown-content">
                                    <button class="dropdown-item" data-category="mainProjects">Projetos Principais</button>
                                    <button class="dropdown-item" data-category="proposed">Proj. Propostos</button>
                                    <button class="dropdown-item" data-category="inProgress">Proj. em Andamento</button>
                                    <button class="dropdown-item" data-category="future">Proj. Futuros</button>
                                </div>
                            </div>
                            <button class="edit-btn">Editar</button>
                            <button class="delete-btn">Excluir</button>
                            <button class="subtask-btn">Subtarefa</button>
                            ${task.notes && task.notes.trim() !== '' ? '<span class="has-notes">(Contém Nota)</span>' : ''}
                        </div>
                        <div class="notes">
                            <textarea rows="3">${task.notes || ''}</textarea>
                        </div>
                        <div class="subtasks-container ${expandedTasks[key] ? 'visible' : ''}"></div>
                    `;

                    const subtasksContainer = li.querySelector('.subtasks-container');
                    if (hasSubtasks) {
                        renderSubtasks(key, task, subtasksContainer);
                    }
                    taskList.appendChild(li);

                    li.querySelector('.task-text').addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleNotes(li);
                    });
                    if (hasSubtasks) {
                        li.querySelector('.expand-btn').addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleSubtasks(key, '', li);
                        });
                    }
                    const categoryBtn = li.querySelector('.category-btn');
                    categoryBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        toggleCategoryDropdown(categoryBtn.parentElement);
                    });
                    li.querySelectorAll('.dropdown-item').forEach(item => {
                        item.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const newCategory = item.getAttribute('data-category');
                            changeCategory(key, newCategory);
                            item.closest('.dropdown-content').style.display = 'none';
                        });
                    });
                    li.querySelector('.edit-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        editTask(key);
                    });
                    li.querySelector('.delete-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        deleteTask(key);
                    });
                    li.querySelector('.subtask-btn').addEventListener('click', (e) => {
                        e.stopPropagation();
                        addSubtask(key);
                    });
                    const notesIndicator = li.querySelector('.has-notes');
                    if (notesIndicator) {
                        notesIndicator.addEventListener('click', (e) => {
                            e.stopPropagation();
                            toggleNotes(li);
                        });
                    }
                    li.querySelector('textarea').addEventListener('change', (e) => updateNotes(key, e.target));
                    li.querySelector('textarea').addEventListener('click', (e) => e.stopPropagation());
                });

                // Handler de checkbox simplificado
                document.querySelectorAll('input[type="checkbox"]').forEach(checkbox => {
                    checkbox.removeEventListener('click', checkbox._clickHandler); // Remove handlers anteriores
                    const handler = (e) => {
                        e.stopPropagation();
                        const id = checkbox.getAttribute('data-id');
                        const parts = id.split('/').filter(p => p !== '');
                        const key = parts[0];
                        if (parts.length === 1) {
                            toggleTask(key);
                        } else {
                            const path = parts.slice(1, -1).join('/');
                            const index = parseInt(parts[parts.length - 1]);
                            toggleSubtask(key, path, index);
                        }
                    };
                    checkbox._clickHandler = handler;
                    checkbox.addEventListener('click', handler);
                });

                document.addEventListener('click', (e) => {
                    if (!e.target.closest('.category-dropdown')) {
                        document.querySelectorAll('.dropdown-content').forEach(content => content.style.display = 'none');
                    }
                });
            });
        }

        setCategory('mainProjects');
        document.getElementById('mainProjectsBtn').addEventListener('click', () => setCategory('mainProjects'));
        document.getElementById('proposedBtn').addEventListener('click', () => setCategory('proposed'));
        document.getElementById('inProgressBtn').addEventListener('click', () => setCategory('inProgress'));
        document.getElementById('futureBtn').addEventListener('click', () => setCategory('future'));
        document.getElementById('allBtn').addEventListener('click', () => setCategory('all'));
        document.getElementById('actionButton').addEventListener('click', () => saveTask(editingSubtask ? editingSubtask.parentKey : (addingSubtaskToKey ? addingSubtaskToKey.key : editingTaskKey)));
        document.getElementById('taskInput').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveTask(editingSubtask ? editingSubtask.parentKey : (addingSubtaskToKey ? addingSubtaskToKey.key : editingTaskKey));
            }
        });
        document.getElementById('dueDate').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveTask(editingSubtask ? editingSubtask.parentKey : (addingSubtaskToKey ? addingSubtaskToKey.key : editingTaskKey));
            }
        });
        document.getElementById('priority').addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                e.preventDefault();
                saveTask(editingSubtask ? editingSubtask.parentKey : (addingSubtaskToKey ? addingSubtaskToKey.key : editingTaskKey));
            }
        });
    </script>
</body>
</html>
